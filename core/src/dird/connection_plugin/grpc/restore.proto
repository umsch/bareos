/*
 * LICENSE HERE
 */

syntax = "proto3";

package bareos.restore;

import "config.proto";
import "common.proto";

service Restore {
  rpc ListSessions (ListSessionsRequest) returns (ListSessionsResponse);
  rpc Begin (BeginRequest) returns (BeginResponse);

  rpc GetState(GetStateRequest) returns (GetStateResponse);
  rpc UpdateState(UpdateStateRequest) returns (UpdateStateResponse);

  // these functions will only work once the tree is created
  // todo: how do plugin files work
  rpc ListFiles (ListFilesRequest) returns (stream File);

  rpc ChangeDirectory (ChangeDirectoryRequest) returns (ChangeDirectoryResponse);
  rpc ChangeMarkedStatus (ChangeMarkedRequest) returns (ChangeMarkedResponse);

  rpc PathToFile (PathToFileRequest) returns (PathToFileResponse);

  rpc CurrentDirectory (CurrentDirectoryRequest) returns (CurrentDirectoryResponse);

  // maybe list marked files as function

  rpc Run (RunRequest) returns (RunResponse);
  rpc Cancel (CancelRequest) returns (CancelResponse);
}

message SessionState {
  bareos.config.CatalogId catalog = 1;
  bareos.common.Job backup_job = 2;
  bool can_run = 3;

  RestoreOptions restore_options = 4;
};

message GetStateRequest {
  RestoreSession session = 1;
};

message GetStateResponse {
  SessionState state = 1;
};

message UpdateStateRequest {
  RestoreSession session = 1;
  RestoreOptions new_options = 2;
};

message UpdateStateResponse {
  SessionState state = 1;
};

message ListSessionsRequest {
};

message ListSessionsResponse {
  repeated RestoreSession sessions = 1;
};

message BeginRequest {
  bareos.common.Job backup_job = 1;
  bool find_job_chain = 2;
};

message RestoreSession {
  string token = 1;
};

message BeginResponse {
  RestoreSession session = 1;
};

enum ReplaceType {
  REPLACE_TYPE_UNSPECIFIED = 0;
  ALWAYS = 1;
  NEVER = 2;
  IF_NEWER = 3;
  IF_OLDER = 4;
};

message RestoreOptions {
  optional ReplaceType replace = 1;
  optional bareos.config.JobId restore_job = 3;
  optional string restore_location = 4;
  optional bareos.common.Client restore_client = 5;
};

message RunRequest {
  RestoreSession session = 1;
  RestoreOptions restore_options = 2;
};

message RunResponse {
  bareos.common.Job jobid = 1;
}

message CancelRequest {
  RestoreSession session = 1;
};

message CancelResponse {}

message Path {
  string path = 1;
};

message PathToFileRequest {
  RestoreSession session = 1;
  Path p = 2;
}

message PathToFileResponse {
  File f = 1;
}

message PathSegments {
  // 0 -> leaf
  // last -> root
  repeated File segments = 1;
};

message CurrentDirectoryRequest {
  RestoreSession session = 1;
};

message CurrentDirectoryResponse {
  PathSegments current_dir = 1;
};

message ChangeDirectoryRequest {
  RestoreSession session = 1;
  // this path can be relative
  FileId directory = 2;
}

message ChangeDirectoryResponse {
  PathSegments current_dir = 1;
}

enum MarkAction {
  MARK_ACTION_UNSPECIFIED = 0;
  MARK = 1;
  UNMARK = 2;
};

message Regex {
  string regex = 1;
};

message ChangeMarkedRequest {
  RestoreSession session = 1;
  MarkAction action = 2;

  // mark/unmark everything under the current directory that matches the regex
  FileId affected_id = 3;
  // if set and the file is a directory, then we recursively mark all
  // files inside that directory
  bool recursive = 4;
}

message ChangeMarkedResponse {
}

message ListFilesRequest {
  RestoreSession session = 1;

  // if root is not set, then the current directory is used
  optional FileId root = 2;
}

enum FileType {
  FILE_TYPE_UNSPECIFIED = 0;
  DIRECTORY = 1;
  FILE = 2;
  DIRECTORY_NOT_BACKED_UP = 3;
};

message FileId {
  uint64 value = 1;
};

message File {
  FileId id = 4;
  string name = 1;
  bool marked = 2;
  FileType type = 3;
}
