// @generated by protobuf-ts 2.9.4 with parameter generate_dependencies,long_type_number
// @generated from protobuf file "restore.proto" (package "bareos.restore", syntax proto3)
// tslint:disable
//
//
// LICENSE HERE
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ClientId } from "./config";
import { JobId as JobId$ } from "./config";
import { CatalogId } from "./config";
import { JobId } from "./database";
/**
 * @generated from protobuf message bareos.restore.StartSelection
 */
export interface StartSelection {
    /**
     * @generated from protobuf field: bareos.database.JobId backup_job = 1;
     */
    backupJob?: JobId;
    /**
     * @generated from protobuf field: bool find_job_chain = 2;
     */
    findJobChain: boolean;
    /**
     * @generated from protobuf field: bool merge_filesets = 3;
     */
    mergeFilesets: boolean;
    /**
     * @generated from protobuf field: bareos.config.CatalogId catalog = 4;
     */
    catalog?: CatalogId;
}
/**
 * @generated from protobuf message bareos.restore.SessionState
 */
export interface SessionState {
    /**
     * @generated from protobuf field: bareos.restore.StartSelection start = 1;
     */
    start?: StartSelection;
    /**
     * @generated from protobuf field: uint64 files_marked_count = 3;
     */
    filesMarkedCount: number;
    /**
     * @generated from protobuf field: bareos.restore.RestoreOptions restore_options = 4;
     */
    restoreOptions?: RestoreOptions;
}
/**
 * @generated from protobuf message bareos.restore.GetStateRequest
 */
export interface GetStateRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
}
/**
 * @generated from protobuf message bareos.restore.GetStateResponse
 */
export interface GetStateResponse {
    /**
     * @generated from protobuf field: bareos.restore.SessionState state = 1;
     */
    state?: SessionState;
}
/**
 * @generated from protobuf message bareos.restore.UpdateStateRequest
 */
export interface UpdateStateRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
    /**
     * @generated from protobuf field: bareos.restore.RestoreOptions new_options = 2;
     */
    newOptions?: RestoreOptions;
}
/**
 * @generated from protobuf message bareos.restore.UpdateStateResponse
 */
export interface UpdateStateResponse {
    /**
     * @generated from protobuf field: bareos.restore.SessionState state = 1;
     */
    state?: SessionState;
}
/**
 * @generated from protobuf message bareos.restore.ListSessionsRequest
 */
export interface ListSessionsRequest {
}
/**
 * @generated from protobuf message bareos.restore.ListSessionsResponse
 */
export interface ListSessionsResponse {
    /**
     * @generated from protobuf field: repeated bareos.restore.RestoreSession sessions = 1;
     */
    sessions: RestoreSession[];
}
/**
 * @generated from protobuf message bareos.restore.BeginRequest
 */
export interface BeginRequest {
    /**
     * @generated from protobuf field: bareos.restore.StartSelection start = 1;
     */
    start?: StartSelection;
}
/**
 * @generated from protobuf message bareos.restore.RestoreSession
 */
export interface RestoreSession {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message bareos.restore.BeginResponse
 */
export interface BeginResponse {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
}
/**
 * @generated from protobuf message bareos.restore.RestoreOptions
 */
export interface RestoreOptions {
    /**
     * @generated from protobuf field: optional bareos.restore.ReplaceType replace = 1;
     */
    replace?: ReplaceType;
    /**
     * @generated from protobuf field: optional bareos.config.JobId restore_job = 3;
     */
    restoreJob?: JobId$;
    /**
     * @generated from protobuf field: optional string restore_location = 4;
     */
    restoreLocation?: string;
    /**
     * @generated from protobuf field: optional bareos.config.ClientId restore_client = 5;
     */
    restoreClient?: ClientId;
}
/**
 * @generated from protobuf message bareos.restore.RunRequest
 */
export interface RunRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
}
/**
 * @generated from protobuf message bareos.restore.RunResponse
 */
export interface RunResponse {
    /**
     * @generated from protobuf field: bareos.database.JobId jobid = 1;
     */
    jobid?: JobId;
}
/**
 * @generated from protobuf message bareos.restore.CancelRequest
 */
export interface CancelRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
}
/**
 * @generated from protobuf message bareos.restore.CancelResponse
 */
export interface CancelResponse {
}
/**
 * @generated from protobuf message bareos.restore.Path
 */
export interface Path {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * @generated from protobuf message bareos.restore.PathToFileRequest
 */
export interface PathToFileRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
    /**
     * @generated from protobuf field: bareos.restore.Path p = 2;
     */
    p?: Path;
}
/**
 * @generated from protobuf message bareos.restore.PathToFileResponse
 */
export interface PathToFileResponse {
    /**
     * @generated from protobuf field: bareos.restore.File f = 1;
     */
    f?: File;
}
/**
 * @generated from protobuf message bareos.restore.PathSegments
 */
export interface PathSegments {
    /**
     * 0 -> leaf
     * last -> root
     *
     * @generated from protobuf field: repeated bareos.restore.File segments = 1;
     */
    segments: File[];
}
/**
 * @generated from protobuf message bareos.restore.CurrentDirectoryRequest
 */
export interface CurrentDirectoryRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
}
/**
 * @generated from protobuf message bareos.restore.CurrentDirectoryResponse
 */
export interface CurrentDirectoryResponse {
    /**
     * @generated from protobuf field: bareos.restore.PathSegments current_dir = 1;
     */
    currentDir?: PathSegments;
}
/**
 * @generated from protobuf message bareos.restore.ChangeDirectoryRequest
 */
export interface ChangeDirectoryRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
    /**
     * this path can be relative
     *
     * @generated from protobuf field: bareos.restore.FileId directory = 2;
     */
    directory?: FileId;
}
/**
 * @generated from protobuf message bareos.restore.ChangeDirectoryResponse
 */
export interface ChangeDirectoryResponse {
    /**
     * @generated from protobuf field: bareos.restore.PathSegments current_dir = 1;
     */
    currentDir?: PathSegments;
}
/**
 * @generated from protobuf message bareos.restore.Regex
 */
export interface Regex {
    /**
     * @generated from protobuf field: string regex = 1;
     */
    regex: string;
}
/**
 * @generated from protobuf message bareos.restore.ChangeMarkedRequest
 */
export interface ChangeMarkedRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
    /**
     * @generated from protobuf field: bareos.restore.MarkAction action = 2;
     */
    action: MarkAction;
    /**
     * mark/unmark everything under the current directory that matches the regex
     *
     * @generated from protobuf field: bareos.restore.FileId affected_id = 3;
     */
    affectedId?: FileId;
    /**
     * if set and the file is a directory, then we recursively mark all
     * files inside that directory
     *
     * @generated from protobuf field: bool recursive = 4;
     */
    recursive: boolean;
}
/**
 * @generated from protobuf message bareos.restore.ChangeMarkedResponse
 */
export interface ChangeMarkedResponse {
}
/**
 * @generated from protobuf message bareos.restore.ListFilesRequest
 */
export interface ListFilesRequest {
    /**
     * @generated from protobuf field: bareos.restore.RestoreSession session = 1;
     */
    session?: RestoreSession;
    /**
     * if root is not set, then the current directory is used
     *
     * @generated from protobuf field: optional bareos.restore.FileId root = 2;
     */
    root?: FileId;
}
/**
 * @generated from protobuf message bareos.restore.FileId
 */
export interface FileId {
    /**
     * @generated from protobuf field: uint64 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message bareos.restore.File
 */
export interface File {
    /**
     * @generated from protobuf field: bareos.restore.FileId id = 4;
     */
    id?: FileId;
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bool marked = 2;
     */
    marked: boolean;
    /**
     * @generated from protobuf field: bareos.restore.FileType type = 3;
     */
    type: FileType;
}
/**
 * @generated from protobuf enum bareos.restore.ReplaceType
 */
export enum ReplaceType {
    /**
     * @generated from protobuf enum value: REPLACE_TYPE_UNSPECIFIED = 0;
     */
    REPLACE_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ALWAYS = 1;
     */
    ALWAYS = 1,
    /**
     * @generated from protobuf enum value: NEVER = 2;
     */
    NEVER = 2,
    /**
     * @generated from protobuf enum value: IF_NEWER = 3;
     */
    IF_NEWER = 3,
    /**
     * @generated from protobuf enum value: IF_OLDER = 4;
     */
    IF_OLDER = 4
}
/**
 * @generated from protobuf enum bareos.restore.MarkAction
 */
export enum MarkAction {
    /**
     * @generated from protobuf enum value: MARK_ACTION_UNSPECIFIED = 0;
     */
    MARK_ACTION_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: MARK = 1;
     */
    MARK = 1,
    /**
     * @generated from protobuf enum value: UNMARK = 2;
     */
    UNMARK = 2
}
/**
 * @generated from protobuf enum bareos.restore.FileType
 */
export enum FileType {
    /**
     * @generated from protobuf enum value: FILE_TYPE_UNSPECIFIED = 0;
     */
    FILE_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DIRECTORY = 1;
     */
    DIRECTORY = 1,
    /**
     * @generated from protobuf enum value: FILE = 2;
     */
    FILE = 2,
    /**
     * @generated from protobuf enum value: DIRECTORY_NOT_BACKED_UP = 3;
     */
    DIRECTORY_NOT_BACKED_UP = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class StartSelection$Type extends MessageType<StartSelection> {
    constructor() {
        super("bareos.restore.StartSelection", [
            { no: 1, name: "backup_job", kind: "message", T: () => JobId },
            { no: 2, name: "find_job_chain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "merge_filesets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "catalog", kind: "message", T: () => CatalogId }
        ]);
    }
    create(value?: PartialMessage<StartSelection>): StartSelection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.findJobChain = false;
        message.mergeFilesets = false;
        if (value !== undefined)
            reflectionMergePartial<StartSelection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSelection): StartSelection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.database.JobId backup_job */ 1:
                    message.backupJob = JobId.internalBinaryRead(reader, reader.uint32(), options, message.backupJob);
                    break;
                case /* bool find_job_chain */ 2:
                    message.findJobChain = reader.bool();
                    break;
                case /* bool merge_filesets */ 3:
                    message.mergeFilesets = reader.bool();
                    break;
                case /* bareos.config.CatalogId catalog */ 4:
                    message.catalog = CatalogId.internalBinaryRead(reader, reader.uint32(), options, message.catalog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSelection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.database.JobId backup_job = 1; */
        if (message.backupJob)
            JobId.internalBinaryWrite(message.backupJob, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool find_job_chain = 2; */
        if (message.findJobChain !== false)
            writer.tag(2, WireType.Varint).bool(message.findJobChain);
        /* bool merge_filesets = 3; */
        if (message.mergeFilesets !== false)
            writer.tag(3, WireType.Varint).bool(message.mergeFilesets);
        /* bareos.config.CatalogId catalog = 4; */
        if (message.catalog)
            CatalogId.internalBinaryWrite(message.catalog, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.StartSelection
 */
export const StartSelection = new StartSelection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionState$Type extends MessageType<SessionState> {
    constructor() {
        super("bareos.restore.SessionState", [
            { no: 1, name: "start", kind: "message", T: () => StartSelection },
            { no: 3, name: "files_marked_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "restore_options", kind: "message", T: () => RestoreOptions }
        ]);
    }
    create(value?: PartialMessage<SessionState>): SessionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filesMarkedCount = 0;
        if (value !== undefined)
            reflectionMergePartial<SessionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionState): SessionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.StartSelection start */ 1:
                    message.start = StartSelection.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* uint64 files_marked_count */ 3:
                    message.filesMarkedCount = reader.uint64().toNumber();
                    break;
                case /* bareos.restore.RestoreOptions restore_options */ 4:
                    message.restoreOptions = RestoreOptions.internalBinaryRead(reader, reader.uint32(), options, message.restoreOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.StartSelection start = 1; */
        if (message.start)
            StartSelection.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 files_marked_count = 3; */
        if (message.filesMarkedCount !== 0)
            writer.tag(3, WireType.Varint).uint64(message.filesMarkedCount);
        /* bareos.restore.RestoreOptions restore_options = 4; */
        if (message.restoreOptions)
            RestoreOptions.internalBinaryWrite(message.restoreOptions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.SessionState
 */
export const SessionState = new SessionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStateRequest$Type extends MessageType<GetStateRequest> {
    constructor() {
        super("bareos.restore.GetStateRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<GetStateRequest>): GetStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStateRequest): GetStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.GetStateRequest
 */
export const GetStateRequest = new GetStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStateResponse$Type extends MessageType<GetStateResponse> {
    constructor() {
        super("bareos.restore.GetStateResponse", [
            { no: 1, name: "state", kind: "message", T: () => SessionState }
        ]);
    }
    create(value?: PartialMessage<GetStateResponse>): GetStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStateResponse): GetStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.SessionState state */ 1:
                    message.state = SessionState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.SessionState state = 1; */
        if (message.state)
            SessionState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.GetStateResponse
 */
export const GetStateResponse = new GetStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStateRequest$Type extends MessageType<UpdateStateRequest> {
    constructor() {
        super("bareos.restore.UpdateStateRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession },
            { no: 2, name: "new_options", kind: "message", T: () => RestoreOptions }
        ]);
    }
    create(value?: PartialMessage<UpdateStateRequest>): UpdateStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStateRequest): UpdateStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* bareos.restore.RestoreOptions new_options */ 2:
                    message.newOptions = RestoreOptions.internalBinaryRead(reader, reader.uint32(), options, message.newOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bareos.restore.RestoreOptions new_options = 2; */
        if (message.newOptions)
            RestoreOptions.internalBinaryWrite(message.newOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.UpdateStateRequest
 */
export const UpdateStateRequest = new UpdateStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStateResponse$Type extends MessageType<UpdateStateResponse> {
    constructor() {
        super("bareos.restore.UpdateStateResponse", [
            { no: 1, name: "state", kind: "message", T: () => SessionState }
        ]);
    }
    create(value?: PartialMessage<UpdateStateResponse>): UpdateStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStateResponse): UpdateStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.SessionState state */ 1:
                    message.state = SessionState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.SessionState state = 1; */
        if (message.state)
            SessionState.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.UpdateStateResponse
 */
export const UpdateStateResponse = new UpdateStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSessionsRequest$Type extends MessageType<ListSessionsRequest> {
    constructor() {
        super("bareos.restore.ListSessionsRequest", []);
    }
    create(value?: PartialMessage<ListSessionsRequest>): ListSessionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListSessionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSessionsRequest): ListSessionsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListSessionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ListSessionsRequest
 */
export const ListSessionsRequest = new ListSessionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSessionsResponse$Type extends MessageType<ListSessionsResponse> {
    constructor() {
        super("bareos.restore.ListSessionsResponse", [
            { no: 1, name: "sessions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<ListSessionsResponse>): ListSessionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessions = [];
        if (value !== undefined)
            reflectionMergePartial<ListSessionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSessionsResponse): ListSessionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bareos.restore.RestoreSession sessions */ 1:
                    message.sessions.push(RestoreSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSessionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bareos.restore.RestoreSession sessions = 1; */
        for (let i = 0; i < message.sessions.length; i++)
            RestoreSession.internalBinaryWrite(message.sessions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ListSessionsResponse
 */
export const ListSessionsResponse = new ListSessionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginRequest$Type extends MessageType<BeginRequest> {
    constructor() {
        super("bareos.restore.BeginRequest", [
            { no: 1, name: "start", kind: "message", T: () => StartSelection }
        ]);
    }
    create(value?: PartialMessage<BeginRequest>): BeginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BeginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginRequest): BeginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.StartSelection start */ 1:
                    message.start = StartSelection.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.StartSelection start = 1; */
        if (message.start)
            StartSelection.internalBinaryWrite(message.start, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.BeginRequest
 */
export const BeginRequest = new BeginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreSession$Type extends MessageType<RestoreSession> {
    constructor() {
        super("bareos.restore.RestoreSession", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RestoreSession>): RestoreSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<RestoreSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreSession): RestoreSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.RestoreSession
 */
export const RestoreSession = new RestoreSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginResponse$Type extends MessageType<BeginResponse> {
    constructor() {
        super("bareos.restore.BeginResponse", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<BeginResponse>): BeginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BeginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginResponse): BeginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.BeginResponse
 */
export const BeginResponse = new BeginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreOptions$Type extends MessageType<RestoreOptions> {
    constructor() {
        super("bareos.restore.RestoreOptions", [
            { no: 1, name: "replace", kind: "enum", opt: true, T: () => ["bareos.restore.ReplaceType", ReplaceType] },
            { no: 3, name: "restore_job", kind: "message", T: () => JobId$ },
            { no: 4, name: "restore_location", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "restore_client", kind: "message", T: () => ClientId }
        ]);
    }
    create(value?: PartialMessage<RestoreOptions>): RestoreOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RestoreOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreOptions): RestoreOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bareos.restore.ReplaceType replace */ 1:
                    message.replace = reader.int32();
                    break;
                case /* optional bareos.config.JobId restore_job */ 3:
                    message.restoreJob = JobId$.internalBinaryRead(reader, reader.uint32(), options, message.restoreJob);
                    break;
                case /* optional string restore_location */ 4:
                    message.restoreLocation = reader.string();
                    break;
                case /* optional bareos.config.ClientId restore_client */ 5:
                    message.restoreClient = ClientId.internalBinaryRead(reader, reader.uint32(), options, message.restoreClient);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bareos.restore.ReplaceType replace = 1; */
        if (message.replace !== undefined)
            writer.tag(1, WireType.Varint).int32(message.replace);
        /* optional bareos.config.JobId restore_job = 3; */
        if (message.restoreJob)
            JobId$.internalBinaryWrite(message.restoreJob, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional string restore_location = 4; */
        if (message.restoreLocation !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.restoreLocation);
        /* optional bareos.config.ClientId restore_client = 5; */
        if (message.restoreClient)
            ClientId.internalBinaryWrite(message.restoreClient, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.RestoreOptions
 */
export const RestoreOptions = new RestoreOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunRequest$Type extends MessageType<RunRequest> {
    constructor() {
        super("bareos.restore.RunRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<RunRequest>): RunRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunRequest): RunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.RunRequest
 */
export const RunRequest = new RunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunResponse$Type extends MessageType<RunResponse> {
    constructor() {
        super("bareos.restore.RunResponse", [
            { no: 1, name: "jobid", kind: "message", T: () => JobId }
        ]);
    }
    create(value?: PartialMessage<RunResponse>): RunResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunResponse): RunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.database.JobId jobid */ 1:
                    message.jobid = JobId.internalBinaryRead(reader, reader.uint32(), options, message.jobid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.database.JobId jobid = 1; */
        if (message.jobid)
            JobId.internalBinaryWrite(message.jobid, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.RunResponse
 */
export const RunResponse = new RunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelRequest$Type extends MessageType<CancelRequest> {
    constructor() {
        super("bareos.restore.CancelRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<CancelRequest>): CancelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelRequest): CancelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.CancelRequest
 */
export const CancelRequest = new CancelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelResponse$Type extends MessageType<CancelResponse> {
    constructor() {
        super("bareos.restore.CancelResponse", []);
    }
    create(value?: PartialMessage<CancelResponse>): CancelResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelResponse): CancelResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.CancelResponse
 */
export const CancelResponse = new CancelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Path$Type extends MessageType<Path> {
    constructor() {
        super("bareos.restore.Path", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Path>): Path {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<Path>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Path): Path {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Path, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.Path
 */
export const Path = new Path$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathToFileRequest$Type extends MessageType<PathToFileRequest> {
    constructor() {
        super("bareos.restore.PathToFileRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession },
            { no: 2, name: "p", kind: "message", T: () => Path }
        ]);
    }
    create(value?: PartialMessage<PathToFileRequest>): PathToFileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PathToFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathToFileRequest): PathToFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* bareos.restore.Path p */ 2:
                    message.p = Path.internalBinaryRead(reader, reader.uint32(), options, message.p);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathToFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bareos.restore.Path p = 2; */
        if (message.p)
            Path.internalBinaryWrite(message.p, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.PathToFileRequest
 */
export const PathToFileRequest = new PathToFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathToFileResponse$Type extends MessageType<PathToFileResponse> {
    constructor() {
        super("bareos.restore.PathToFileResponse", [
            { no: 1, name: "f", kind: "message", T: () => File }
        ]);
    }
    create(value?: PartialMessage<PathToFileResponse>): PathToFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PathToFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathToFileResponse): PathToFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.File f */ 1:
                    message.f = File.internalBinaryRead(reader, reader.uint32(), options, message.f);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathToFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.File f = 1; */
        if (message.f)
            File.internalBinaryWrite(message.f, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.PathToFileResponse
 */
export const PathToFileResponse = new PathToFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathSegments$Type extends MessageType<PathSegments> {
    constructor() {
        super("bareos.restore.PathSegments", [
            { no: 1, name: "segments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => File }
        ]);
    }
    create(value?: PartialMessage<PathSegments>): PathSegments {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.segments = [];
        if (value !== undefined)
            reflectionMergePartial<PathSegments>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathSegments): PathSegments {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bareos.restore.File segments */ 1:
                    message.segments.push(File.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathSegments, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bareos.restore.File segments = 1; */
        for (let i = 0; i < message.segments.length; i++)
            File.internalBinaryWrite(message.segments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.PathSegments
 */
export const PathSegments = new PathSegments$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentDirectoryRequest$Type extends MessageType<CurrentDirectoryRequest> {
    constructor() {
        super("bareos.restore.CurrentDirectoryRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession }
        ]);
    }
    create(value?: PartialMessage<CurrentDirectoryRequest>): CurrentDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CurrentDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentDirectoryRequest): CurrentDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.CurrentDirectoryRequest
 */
export const CurrentDirectoryRequest = new CurrentDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentDirectoryResponse$Type extends MessageType<CurrentDirectoryResponse> {
    constructor() {
        super("bareos.restore.CurrentDirectoryResponse", [
            { no: 1, name: "current_dir", kind: "message", T: () => PathSegments }
        ]);
    }
    create(value?: PartialMessage<CurrentDirectoryResponse>): CurrentDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CurrentDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentDirectoryResponse): CurrentDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.PathSegments current_dir */ 1:
                    message.currentDir = PathSegments.internalBinaryRead(reader, reader.uint32(), options, message.currentDir);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.PathSegments current_dir = 1; */
        if (message.currentDir)
            PathSegments.internalBinaryWrite(message.currentDir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.CurrentDirectoryResponse
 */
export const CurrentDirectoryResponse = new CurrentDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeDirectoryRequest$Type extends MessageType<ChangeDirectoryRequest> {
    constructor() {
        super("bareos.restore.ChangeDirectoryRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession },
            { no: 2, name: "directory", kind: "message", T: () => FileId }
        ]);
    }
    create(value?: PartialMessage<ChangeDirectoryRequest>): ChangeDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeDirectoryRequest): ChangeDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* bareos.restore.FileId directory */ 2:
                    message.directory = FileId.internalBinaryRead(reader, reader.uint32(), options, message.directory);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bareos.restore.FileId directory = 2; */
        if (message.directory)
            FileId.internalBinaryWrite(message.directory, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ChangeDirectoryRequest
 */
export const ChangeDirectoryRequest = new ChangeDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeDirectoryResponse$Type extends MessageType<ChangeDirectoryResponse> {
    constructor() {
        super("bareos.restore.ChangeDirectoryResponse", [
            { no: 1, name: "current_dir", kind: "message", T: () => PathSegments }
        ]);
    }
    create(value?: PartialMessage<ChangeDirectoryResponse>): ChangeDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeDirectoryResponse): ChangeDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.PathSegments current_dir */ 1:
                    message.currentDir = PathSegments.internalBinaryRead(reader, reader.uint32(), options, message.currentDir);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.PathSegments current_dir = 1; */
        if (message.currentDir)
            PathSegments.internalBinaryWrite(message.currentDir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ChangeDirectoryResponse
 */
export const ChangeDirectoryResponse = new ChangeDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Regex$Type extends MessageType<Regex> {
    constructor() {
        super("bareos.restore.Regex", [
            { no: 1, name: "regex", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Regex>): Regex {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regex = "";
        if (value !== undefined)
            reflectionMergePartial<Regex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Regex): Regex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string regex */ 1:
                    message.regex = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Regex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string regex = 1; */
        if (message.regex !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.regex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.Regex
 */
export const Regex = new Regex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMarkedRequest$Type extends MessageType<ChangeMarkedRequest> {
    constructor() {
        super("bareos.restore.ChangeMarkedRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession },
            { no: 2, name: "action", kind: "enum", T: () => ["bareos.restore.MarkAction", MarkAction] },
            { no: 3, name: "affected_id", kind: "message", T: () => FileId },
            { no: 4, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeMarkedRequest>): ChangeMarkedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.recursive = false;
        if (value !== undefined)
            reflectionMergePartial<ChangeMarkedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMarkedRequest): ChangeMarkedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* bareos.restore.MarkAction action */ 2:
                    message.action = reader.int32();
                    break;
                case /* bareos.restore.FileId affected_id */ 3:
                    message.affectedId = FileId.internalBinaryRead(reader, reader.uint32(), options, message.affectedId);
                    break;
                case /* bool recursive */ 4:
                    message.recursive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMarkedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bareos.restore.MarkAction action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* bareos.restore.FileId affected_id = 3; */
        if (message.affectedId)
            FileId.internalBinaryWrite(message.affectedId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool recursive = 4; */
        if (message.recursive !== false)
            writer.tag(4, WireType.Varint).bool(message.recursive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ChangeMarkedRequest
 */
export const ChangeMarkedRequest = new ChangeMarkedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMarkedResponse$Type extends MessageType<ChangeMarkedResponse> {
    constructor() {
        super("bareos.restore.ChangeMarkedResponse", []);
    }
    create(value?: PartialMessage<ChangeMarkedResponse>): ChangeMarkedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeMarkedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMarkedResponse): ChangeMarkedResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChangeMarkedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ChangeMarkedResponse
 */
export const ChangeMarkedResponse = new ChangeMarkedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFilesRequest$Type extends MessageType<ListFilesRequest> {
    constructor() {
        super("bareos.restore.ListFilesRequest", [
            { no: 1, name: "session", kind: "message", T: () => RestoreSession },
            { no: 2, name: "root", kind: "message", T: () => FileId }
        ]);
    }
    create(value?: PartialMessage<ListFilesRequest>): ListFilesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListFilesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFilesRequest): ListFilesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.RestoreSession session */ 1:
                    message.session = RestoreSession.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* optional bareos.restore.FileId root */ 2:
                    message.root = FileId.internalBinaryRead(reader, reader.uint32(), options, message.root);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFilesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.RestoreSession session = 1; */
        if (message.session)
            RestoreSession.internalBinaryWrite(message.session, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bareos.restore.FileId root = 2; */
        if (message.root)
            FileId.internalBinaryWrite(message.root, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.ListFilesRequest
 */
export const ListFilesRequest = new ListFilesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileId$Type extends MessageType<FileId> {
    constructor() {
        super("bareos.restore.FileId", [
            { no: 1, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<FileId>): FileId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<FileId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileId): FileId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 value */ 1:
                    message.value = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.FileId
 */
export const FileId = new FileId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class File$Type extends MessageType<File> {
    constructor() {
        super("bareos.restore.File", [
            { no: 4, name: "id", kind: "message", T: () => FileId },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "marked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["bareos.restore.FileType", FileType] }
        ]);
    }
    create(value?: PartialMessage<File>): File {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.marked = false;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<File>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: File): File {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bareos.restore.FileId id */ 4:
                    message.id = FileId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool marked */ 2:
                    message.marked = reader.bool();
                    break;
                case /* bareos.restore.FileType type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: File, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bareos.restore.FileId id = 4; */
        if (message.id)
            FileId.internalBinaryWrite(message.id, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool marked = 2; */
        if (message.marked !== false)
            writer.tag(2, WireType.Varint).bool(message.marked);
        /* bareos.restore.FileType type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message bareos.restore.File
 */
export const File = new File$Type();
/**
 * @generated ServiceType for protobuf service bareos.restore.Restore
 */
export const Restore = new ServiceType("bareos.restore.Restore", [
    { name: "ListSessions", options: {}, I: ListSessionsRequest, O: ListSessionsResponse },
    { name: "Begin", options: {}, I: BeginRequest, O: BeginResponse },
    { name: "GetState", options: {}, I: GetStateRequest, O: GetStateResponse },
    { name: "UpdateState", options: {}, I: UpdateStateRequest, O: UpdateStateResponse },
    { name: "ListFiles", serverStreaming: true, options: {}, I: ListFilesRequest, O: File },
    { name: "ChangeDirectory", options: {}, I: ChangeDirectoryRequest, O: ChangeDirectoryResponse },
    { name: "ChangeMarkedStatus", options: {}, I: ChangeMarkedRequest, O: ChangeMarkedResponse },
    { name: "PathToFile", options: {}, I: PathToFileRequest, O: PathToFileResponse },
    { name: "CurrentDirectory", options: {}, I: CurrentDirectoryRequest, O: CurrentDirectoryResponse },
    { name: "Run", options: {}, I: RunRequest, O: RunResponse },
    { name: "Cancel", options: {}, I: CancelRequest, O: CancelResponse }
]);
